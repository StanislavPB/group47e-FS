# Lesson 14



# Lesson 14


Моделирование API на Java - это процесс проектирования и создания интерфейсов приложений (API) с использованием языка программирования Java. Этот процесс включает в себя несколько этапов, начиная с определения требований и заканчивая реализацией и документированием API. Давайте рассмотрим каждый этап более подробно:

1. **Определение требований**:
   Первым шагом в моделировании API является понимание требований к вашему API.
   Это включает в себя определение функциональности, которую должно предоставлять API,
   а также определение типов данных, которые будут передаваться через API и ожидаемых результатов.

2. **Проектирование интерфейса**:
   На этом этапе вы определяете структуру вашего API, включая пути доступа (endpoints),
   методы запросов, параметры и форматы данных. Вам может помочь использование различных инструментов,
   таких как UML-диаграммы или специализированные инструменты для проектирования API.

3. **Выбор архитектурного стиля**:
   Выбор архитектурного стиля API важен для обеспечения эффективности, масштабируемости и безопасности
   вашего приложения. Наиболее популярным в настоящее время является RESTful.

4. **Разработка бизнес-логики**:
   После того как вы определили структуру API, вам нужно реализовать бизнес-логику,
   которая будет выполняться при вызове каждого метода API.
   Здесь важно обеспечить корректную обработку запросов, валидацию данных и выполнение необходимых операций.

5. **Использование библиотек и фреймворков**:
   В Java существует множество библиотек и фреймворков, которые могут упростить создание и поддержку API.
   Эти инструменты предоставляют множество функций, таких как инверсия управления, внедрение зависимостей,
   управление транзакциями и многое другое.

6. **Тестирование API**:
   После реализации API важно протестировать его на соответствие требованиям, а также на безопасность
   и производительность. Это может включать в себя функциональное тестирование, модульное тестирование,
   интеграционное тестирование и нагрузочное тестирование.

7. **Документирование API**:
   Хорошая документация API помогает разработчикам быстро и легко понять, как использовать ваше API.
   Обычно это включает в себя описание каждого метода API, его параметров, возвращаемых значений и возможных ошибок.
   Вы можете использовать инструменты автоматической генерации документации, такие как Swagger или OpenAPI, чтобы упростить этот процесс.

8. **Развертывание и масштабирование**:
   После завершения разработки и тестирования API вы можете развернуть его на сервере и настроить масштабируемость
   для обеспечения отказоустойчивости и эффективности работы при росте нагрузки.

Это основные этапы процесса моделирования API на Java.


### **JSON (JavaScript Object Notation)**
Это легкий формат обмена данными, основанный на подмножестве синтаксиса JavaScript. Он представляет собой текстовый формат, понятный для человека, который легко читается и записывается, а также удобен для машины для разбора и генерации данных.
JSON состоит из пар "ключ: значение", где ключ - это строка, а значение может быть строкой, числом, логическим значением, массивом, объектом или null.

В Spring Boot приложениях JSON широко используется для обмена данными между клиентом и сервером.
Spring Boot обеспечивает удобные средства для работы с JSON, включая автоматическую сериализацию и десериализацию объектов Java в JSON и обратно с использованием Jackson, который является стандартным для многих приложений на Java.

Чтобы использовать JSON в Spring Boot приложении, вы можете использовать аннотации контроллеров, такие как @RestController, которые автоматически сериализуют результаты методов контроллера в JSON.

Пример:

```java
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api")
public class MyController {
    
    @GetMapping("/example")
    public MyObject getExample() {
        MyObject obj = new MyObject();
        obj.setId(1);
        obj.setName("Example");
        return obj;
    }
}
```

```java
public class MyObject {
    
    private int id;
    private String name;
    
    // Геттеры и сеттеры
}
```

В этом примере метод `getExample()` возвращает объект `MyObject`, который автоматически сериализуется в JSON при вызове этого метода.
В результате клиент получит JSON-объект вида `{"id":1,"name":"Example"}`.

Таким образом, JSON является важной частью разработки Spring Boot приложений, поскольку обеспечивает удобный и эффективный способ обмена данными между клиентом и сервером.


### **DTO (Data Transfer Object)**

DTO — это объект, который используется для передачи данных между подсистемами приложения.
Он содержит только поля и getter/setter методы для доступа к ним.
DTO не содержит бизнес-логики и используется только для передачи данных.

## Что такое DTO (Data Transfer Object)?

Зачастую, в клиент-серверных приложениях, данные на клиенте (слой представления) и на сервере (слой предметной области) структурируются по-разному.
На стороне сервера это дает нам возможность комфортно хранить данные в базе данных или оптимизировать использование данных в угоду производительности,
в то же время заниматься “user-friendly” отображением данных на клиенте, и, для серверной части, нужно найти способ как переводить данные из одного формата в другой.
Конечно, существуют и другие архитектуры приложений, но DTO-подобные объекты могут использоваться между любыми двумя слоями представления данных.

DTO — это так называемый value-object на стороне сервера, который хранит данные, используемые в слое представления.
Следует разделять DTO на те, что мы используем при запросе (Request) и на те, что мы возвращаем в качестве ответа сервера (Response).
Они автоматически сериализуются и десериализуются фреймворком Spring.




## Аннотации @Transactional и @Modifier

Они относятся к аспектам управления транзакциями и изменениям состояния данных в приложениях на языке Java, особенно в контексте использования фреймворка Spring.

### Аннотация @Transactional

Аннотация @Transactional в Spring используется для декларирования методов или классов, которые должны выполняться в рамках транзакции. Эта аннотация предоставляет управление транзакциями, позволяя разработчикам указать, как должны обрабатываться транзакции для определённых методов.

#### Основные свойства @Transactional:

1. **propagation**: Определяет поведение метода в транзакции. Возможные значения:
    - **REQUIRED** (по умолчанию): Использует текущую транзакцию, если она существует, или создает новую.
    - **REQUIRES_NEW**: Всегда создает новую транзакцию, приостанавливая текущую, если она существует.
    - **SUPPORTS**: Метод будет работать в транзакции, если она существует, но не создаст новую.
    - **NOT_SUPPORTED**: Метод будет работать вне транзакции, приостанавливая текущую, если она существует.
    - **MANDATORY**: Метод должен быть выполнен в существующей транзакции, иначе вызовет исключение.
    - **NEVER**: Метод должен быть выполнен вне транзакции, иначе вызовет исключение.
    - **NESTED**: Метод будет выполнен в рамках вложенной транзакции, если существует текущая транзакция.

2. **isolation**: Определяет уровень изоляции транзакции, что помогает управлять параллелизмом и предотвращать такие проблемы, как фантомные чтения и грязное чтение. Возможные значения:
    - **DEFAULT**: Использует уровень изоляции базы данных по умолчанию.
    - **READ_UNCOMMITTED**: Позволяет грязное чтение.
    - **READ_COMMITTED**: Предотвращает грязное чтение.
    - **REPEATABLE_READ**: Предотвращает грязное чтение и неповторяющееся чтение.
    - **SERIALIZABLE**: Самый строгий уровень, предотвращает фантомные чтения.

3. **timeout**: Определяет максимальное время (в секундах), в течение которого транзакция должна быть выполнена. Если время превышено, транзакция откатывается.

4. **readOnly**: Указывает, что транзакция является только для чтения. Это может помочь оптимизировать производительность.

5. **rollbackFor** и **noRollbackFor**: Определяют, какие исключения должны приводить к откату транзакции, а какие нет.

Пример использования:
```java
@Service
public class MyService {

    @Transactional(propagation = Propagation.REQUIRED, isolation = Isolation.READ_COMMITTED, timeout = 5, rollbackFor = Exception.class)
    public void myTransactionalMethod() {
        // Логика метода
    }
}
```

### Аннотация @Modifying

Аннотация @Modifying используется в контексте Spring Data JPA для обозначения методов репозитория, которые изменяют состояние базы данных (например, выполняют UPDATE или DELETE запросы). Эта аннотация обычно применяется вместе с @Query, чтобы указать, что метод должен выполнять операцию модификации данных, а не возвращать результат выборки.

#### Основные свойства @Modifying:

1. **clearAutomatically**: Если установлено в true, контекст постоянства будет очищен после выполнения запроса. Это полезно для предотвращения потенциальных проблем с управлением состоянием объектов после выполнения операции модификации.
2. **flushAutomatically**: Если установлено в true, изменения будут автоматически сбрасываться в базу данных перед выполнением запроса.

Пример использования:
```java
public interface UserRepository extends JpaRepository<User, Long> {

    @Modifying
    @Query("update User u set u.name = ?1 where u.id = ?2")
    int updateUserName(String name, Long id);

    @Modifying
    @Query("delete from User u where u.id = ?1")
    void deleteUserById(Long id);
}
```

В этом примере, метод `updateUserName` обновляет имя пользователя, а метод `deleteUserById` удаляет пользователя по идентификатору. Оба метода аннотированы @Modifying, чтобы указать, что они изменяют состояние базы данных.

### Основные моменты, которые следует учитывать при использовании @Transactional и @Modifying:

- Методы, аннотированные @Transactional, управляют поведением транзакций, что позволяет контролировать обработку ошибок и управление параллелизмом.
- Методы, аннотированные @Modifying, используются для выполнения операций, которые изменяют данные в базе, и должны использоваться совместно с @Query для явного указания запросов.

Правильное использование этих аннотаций позволяет эффективно управлять транзакциями и изменениями данных в приложениях, обеспечивая целостность и надежность данных.


Аннотация @Transactional в Spring предоставляет мощный и гибкий механизм для управления транзакциями в Java-приложениях. Это позволяет разработчикам сосредоточиться на бизнес-логике, не беспокоясь о явном управлении транзакциями, которое может быть сложным и подверженным ошибкам. Рассмотрим @Transactional более подробно, включая использование, настройки, и нюансы.

### Основные аспекты @Transactional

#### 1. **Propagation (Распространение транзакций)**

Распространение определяет, как метод должен вести себя в отношении существующих транзакций. Вот детальное описание возможных значений:

- **REQUIRED (По умолчанию)**: Если существует текущая транзакция, метод будет выполнен в её рамках. Если транзакции нет, будет создана новая. Это наиболее распространенное поведение, так как оно позволяет методам работать в одном контексте транзакции.
  ```java
  @Transactional(propagation = Propagation.REQUIRED)
  public void someMethod() {
      // логика
  }
  ```

- **REQUIRES_NEW**: Всегда создаёт новую транзакцию. Если текущая транзакция существует, она будет приостановлена.
  ```java
  @Transactional(propagation = Propagation.REQUIRES_NEW)
  public void someMethod() {
      // логика
  }
  ```

- **SUPPORTS**: Метод будет выполнен в рамках текущей транзакции, если она существует. Если нет, он будет выполнен вне транзакции.
  ```java
  @Transactional(propagation = Propagation.SUPPORTS)
  public void someMethod() {
      // логика
  }
  ```

- **NOT_SUPPORTED**: Метод будет выполнен вне транзакции. Если текущая транзакция существует, она будет приостановлена.
  ```java
  @Transactional(propagation = Propagation.NOT_SUPPORTED)
  public void someMethod() {
      // логика
  }
  ```

- **MANDATORY**: Метод должен быть выполнен в рамках существующей транзакции. Если текущей транзакции нет, будет выброшено исключение.
  ```java
  @Transactional(propagation = Propagation.MANDATORY)
  public void someMethod() {
      // логика
  }
  ```

- **NEVER**: Метод должен быть выполнен вне транзакции. Если текущая транзакция существует, будет выброшено исключение.
  ```java
  @Transactional(propagation = Propagation.NEVER)
  public void someMethod() {
      // логика
  }
  ```

- **NESTED**: Если существует текущая транзакция, метод будет выполнен в рамках вложенной транзакции. Вложенные транзакции поддерживаются на уровне базы данных с помощью сохраненных точек.
  ```java
  @Transactional(propagation = Propagation.NESTED)
  public void someMethod() {
      // логика
  }
  ```

#### 2. **Isolation (Уровень изоляции)**

Изоляция определяет, насколько одна транзакция видна другим. Это помогает управлять проблемами, связанными с параллельным доступом к данным.

- **DEFAULT**: Использует уровень изоляции по умолчанию, заданный в настройках базы данных.
  ```java
  @Transactional(isolation = Isolation.DEFAULT)
  public void someMethod() {
      // логика
  }
  ```

- **READ_UNCOMMITTED**: Минимальный уровень изоляции, позволяющий грязные чтения. Одни транзакции могут видеть незавершенные изменения других транзакций.
  ```java
  @Transactional(isolation = Isolation.READ_UNCOMMITTED)
  public void someMethod() {
      // логика
  }
  ```

- **READ_COMMITTED**: Обеспечивает, что данные, которые читаются транзакцией, были зафиксированы. Предотвращает грязное чтение.
  ```java
  @Transactional(isolation = Isolation.READ_COMMITTED)
  public void someMethod() {
      // логика
  }
  ```

- **REPEATABLE_READ**: Обеспечивает, что данные, которые читаются транзакцией, не изменяются другими транзакциями до её завершения. Предотвращает грязное чтение и неповторяющееся чтение.
  ```java
  @Transactional(isolation = Isolation.REPEATABLE_READ)
  public void someMethod() {
      // логика
  }
  ```

- **SERIALIZABLE**: Самый строгий уровень изоляции, который обеспечивает выполнение транзакций последовательно, предотвращая все типы аномалий чтения.
  ```java
  @Transactional(isolation = Isolation.SERIALIZABLE)
  public void someMethod() {
      // логика
  }
  ```

#### 3. **Timeout (Таймаут транзакции)**

Таймаут определяет максимальное время в секундах, в течение которого транзакция должна завершиться. Если транзакция не завершится в указанный период, она будет откатана.

```java
@Transactional(timeout = 10)
public void someMethod() {
    // логика
}
```

#### 4. **ReadOnly (Только для чтения)**

Указывает, что транзакция предназначена только для чтения данных. Это может помочь оптимизировать производительность, поскольку база данных может применить оптимизации для чтения.

```java
@Transactional(readOnly = true)
public void someMethod() {
    // логика
}
```

#### 5. **RollbackFor и NoRollbackFor (Условия отката транзакции)**

Эти свойства позволяют указать, при каких исключениях транзакция должна быть откатана или не откатана.

- **rollbackFor**: Список исключений, при которых транзакция должна быть откатана.
  ```java
  @Transactional(rollbackFor = {Exception.class})
  public void someMethod() {
      // логика
  }
  ```

- **noRollbackFor**: Список исключений, при которых транзакция не должна быть откатана.
  ```java
  @Transactional(noRollbackFor = {SpecificException.class})
  public void someMethod() {
      // логика
  }
  ```

### Взаимодействие @Transactional с прокси

Spring AOP (Aspect-Oriented Programming) использует прокси для управления транзакциями. Важно учитывать, что методы, аннотированные @Transactional, должны вызываться извне, чтобы прокси смогло их обернуть и управлять транзакцией. Вызов метода из другого метода того же класса не будет обрабатывать транзакцию должным образом.

### Примеры использования @Transactional

#### Пример 1: Управление транзакцией на уровне класса
Если аннотация @Transactional применяется на уровне класса, все методы этого класса будут транзакционными.

```java
@Service
@Transactional
public class MyService {

    public void method1() {
        // логика
    }

    public void method2() {
        // логика
    }
}
```

#### Пример 2: Управление транзакцией на уровне метода
Можно переопределить транзакционные настройки для отдельных методов.

```java
@Service
public class MyService {

    @Transactional(propagation = Propagation.REQUIRED)
    public void method1() {
        // логика
    }

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void method2() {
        // логика
    }
}
```

### Ловушки и рекомендации

1. **Не вызывайте транзакционные методы напрямую из того же класса**: Это обойдет прокси-объект и транзакция не будет управляться.
2. **Не используйте @Transactional для методов, вызываемых при инициализации**: Например, в конструкторах или методах @PostConstruct, так как контекст транзакции еще не создан.
3. **Всегда проверяйте настройки базы данных**: Некоторые настройки изоляции или поведения транзакций могут не поддерживаться вашей СУБД.
4. **Избегайте длительных транзакций**: Длительные транзакции могут блокировать ресурсы и снижать производительность. Разделяйте операции на логические части, если это возможно.

### Заключение

Аннотация @Transactional является мощным инструментом в арсенале разработчиков Spring, позволяя легко управлять транзакциями и обеспечивать целостность данных. Грамотное использование этой аннотации требует понимания основ транзакционного управления и особенностей вашего приложения и базы данных.

### Разберем пример: мы создали метод в сервисе, который вызывает метод из репозитория. Этот метод меняет только одно поле в записи

Если мы например используем просто аннотацию @Transactional и у нас всё работает, это означает, что транзакционный менеджер Spring успешно обрабатывает транзакцию.
Давайте рассмотрим, почему это происходит и что может пойти не так в определённых сценариях.

### Что происходит в этом случае?

1. **Создание транзакции**: Когда вызывается метод, аннотированный @Transactional, Spring создает транзакцию (если она ещё не существует в текущем контексте).
2. **Вызов метода репозитория**: Внутри транзакции выполняется вызов метода репозитория, который изменяет поле записи в базе данных.
3. **Коммит транзакции**: После завершения работы метода (если не было исключений), транзакция коммитится, то есть изменения фиксируются в базе данных.
4. **Откат транзакции**: Если внутри транзакционного метода возникает исключение, транзакция будет откатана, и изменения не будут сохранены.

### Почему всё работает?

- **Одно поле**: Изменение только одного поля в записи — это простая операция, которая, как правило, не требует сложного управления транзакциями.
- **Метод репозитория**: Репозитории в Spring Data JPA автоматически поддерживают транзакции. Если вы используете стандартные методы репозитория (например, `save`, `delete`), они уже работают в рамках транзакции, инициированной вызовом метода сервиса.
- **Короткая транзакция**: Если метод выполняется быстро и не содержит длительных операций, вероятность возникновения проблем (например, таймаутов или конфликтов блокировок) минимальна.

### Потенциальные проблемы и что может пойти не так?

Хотя наш текущий подход работает, есть несколько потенциальных ловушек, о которых стоит знать:

1. **Вызов метода из того же класса**: Если аннотированный @Transactional метод вызывает другой метод того же класса, который также должен быть транзакционным, транзакция может не обрабатываться правильно. Это связано с тем, что Spring использует прокси для управления транзакциями, и вызовы внутри одного класса не проходят через этот прокси.
   ```java
   @Service
   public class MyService {
       @Transactional
       public void outerMethod() {
           innerMethod(); // Этот вызов не будет обрабатываться прокси
       }

       @Transactional
       public void innerMethod() {
           // логика
       }
   }
   ```

2. **Откат транзакции**: По умолчанию @Transactional откатывает транзакцию только для unchecked exceptions (наследники RuntimeException). Если возникает checked exception, транзакция не будет откатана, если вы явно не укажете это поведение.
   ```java
   @Transactional(rollbackFor = Exception.class)
   public void myMethod() throws Exception {
       // логика
   }
   ```

3. **Параллельное выполнение**: В более сложных сценариях, когда транзакции выполняются параллельно, могут возникнуть проблемы с блокировками или целостностью данных. В таких случаях важно правильно выбирать уровни изоляции транзакций.

4. **Долгие транзакции**: Длительные транзакции могут блокировать ресурсы и негативно влиять на производительность приложения. Избегайте выполнения долгих операций (например, запросов к удалённым сервисам) внутри транзакционных методов.

### Пример правильного использования

```java
@Service
public class UserService {

    private final UserRepository userRepository;

    @Autowired
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    @Transactional
    public void updateUser(Long userId, String newName) {
        User user = userRepository.findById(userId).orElseThrow(() -> new EntityNotFoundException("User not found"));
        user.setName(newName);
        userRepository.save(user);
    }
}
```

В этом примере:

1. Метод `updateUser` аннотирован @Transactional.
2. Метод выполняет операцию поиска пользователя и обновления его имени в рамках одной транзакции.
3. Если возникает исключение (например, пользователь не найден), транзакция будет откатана.

### Заключение

Использование аннотации @Transactional для методов, которые вызывают методы репозиториев, является стандартной практикой и обеспечивает корректное управление транзакциями в большинстве случаев. Однако важно учитывать потенциальные ловушки и гарантировать, что методы вызываются правильным образом для обеспечения надёжного и эффективного управления транзакциями.



