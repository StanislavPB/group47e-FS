# Lesson 19


### Как использовать переменные окружения в Spring Boot

1. **Определение переменных окружения:**
   Переменные окружения могут быть определены в операционной системе или в конфигурационных файлах CI/CD. Например, в Unix-подобных системах вы можете задать переменную окружения в терминале:
   ```bash
   export DATABASE_URL="jdbc:mysql://localhost:3306/mydb"
   ```

2. **Доступ к переменным окружения в приложении:**
   В Spring Boot для доступа к переменным окружения можно использовать аннотацию `@Value`. Например:
   ```java
   @Component
   public class MyComponent {
       @Value("${DATABASE_URL}")
       private String databaseUrl;

       // использование databaseUrl в коде
   }
   ```

3. **Использование `application.properties` или `application.yml`:**
   Вы можете задать значения по умолчанию в этих файлах, которые будут перезаписаны значениями из переменных окружения при необходимости:
   ```properties
   # application.properties
   DATABASE_URL=jdbc:h2:mem:testdb
   ```

   ```yaml
   # application.yml
   DATABASE_URL: jdbc:h2:mem:testdb
   ```

### Нюансы использования переменных окружения в Spring Boot

1. **Приоритеты конфигурации:**
   Spring Boot использует строгую иерархию для определения приоритета конфигурационных данных. Переменные окружения имеют один из самых высоких приоритетов, что позволяет им перезаписывать значения, заданные в `application.properties` или `application.yml`.

2. **Безопасность:**
   Старайтесь не хранить чувствительные данные, такие как пароли или секреты API, прямо в переменных окружения. Используйте для этого защищенные хранилища, например, Spring Cloud Config или HashiCorp Vault.

3. **Профили Spring:**
   Вы можете определить различные профили для разных сред, используя `spring.profiles.active` и определяя переменные окружения для каждой среды соответственно. Это позволяет гибко управлять конфигурацией для различных условий развертывания.

4. **Передача сложных структур данных:**
   Если вам нужно передать сложные структуры данных через переменные окружения, подумайте о форматировании их как строк, возможно, в JSON-формате, который затем можно разобрать в приложении.

Использование переменных окружения улучшает безопасность и упрощает управление конфигурациями приложения, делая его более гибким и адаптируемым к изменениям среды.

При запуске приложения на Spring Boot переменные окружения можно задать несколькими способами в зависимости от среды и способа запуска. Вот несколько основных методов:

### 1. В командной строке
Вы можете установить переменные окружения прямо перед запуском приложения в командной строке. Это работает на любой операционной системе.

**На UNIX-подобных системах (Linux, macOS):**
```bash
export DATABASE_URL="jdbc:mysql://localhost:3306/mydb"
java -jar myapp.jar
```

**На Windows:**
```cmd
set DATABASE_URL=jdbc:mysql://localhost:3306/mydb
java -jar myapp.jar
```

### 2. При запуске через Maven или Gradle
Если вы используете Maven или Gradle для запуска вашего приложения во время разработки, вы можете указать переменные окружения в конфигурации плагина.

**Для Maven:**
```xml
<plugin>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-maven-plugin</artifactId>
    <configuration>
        <environmentVariables>
            <DATABASE_URL>jdbc:mysql://localhost:3306/mydb</DATABASE_URL>
        </environmentVariables>
    </configuration>
</plugin>
```
Затем запускаете:
```bash
mvn spring-boot:run
```

**Для Gradle:**
```groovy
bootRun {
    environment "DATABASE_URL", "jdbc:mysql://localhost:3306/mydb"
}
```
Затем запускаете:
```bash
./gradlew bootRun
```

### 3. В файле конфигурации IDE
Если вы используете IDE, такие как IntelliJ IDEA или Eclipse, вы можете установить переменные окружения в настройках конфигурации запуска вашего приложения.

**В IntelliJ IDEA:**
- Откройте конфигурацию запуска (Run/Debug Configurations).
- Найдите раздел "Environment variables" и установите нужные переменные.

**В Eclipse:**
- Откройте конфигурацию запуска (Run Configurations).
- Во вкладке "Environment" добавьте необходимые переменные окружения.

### 4. В Docker или Kubernetes
При запуске приложений в контейнерах (например, с использованием Docker или Kubernetes) вы также можете задать переменные окружения через конфигурацию контейнера.

**Docker:**
```dockerfile
FROM openjdk:11
COPY target/myapp.jar myapp.jar
ENV DATABASE_URL jdbc:mysql://localhost:3306/mydb
ENTRYPOINT ["java", "-jar", "myapp.jar"]
```

**Kubernetes:**
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: myapp
spec:
  containers:
  - name: myapp
    image: myapp:latest
    env:
    - name: DATABASE_URL
      value: "jdbc:mysql://localhost:3306/mydb"
```

Эти методы позволяют гибко управлять конфигурацией приложения, адаптируя её под разные среды и условия запуска.

## Тестирование контроллеров в Spring Boot

Тестирование контроллеров в Spring Boot обычно включает использование фреймворка `MockMvc`, который позволяет отправлять HTTP-запросы на контроллеры и проверять ответы без запуска полноценного сервера. Вот подробное объяснение основных методов и подходов:

### 1. Инициализация `MockMvc`

- **`MockMvcBuilders.standaloneSetup`**: Этот метод используется для создания конфигурации `MockMvc` для тестирования одного или нескольких контроллеров в изоляции от остальной части приложения. Это идеально подходит для модульного тестирования, так как не требуется загружать полный контекст Spring.
- **`MockMvcBuilders.webAppContextSetup`**: Этот метод требует загрузки полного веб-контекста приложения, что делает его подходящим для интеграционных тестов.

### 2. Конфигурация тестов

- **`@SpringBootTest`**: Эта аннотация используется для загрузки полноценного контекста приложения и применяется в интеграционных тестах, подходит для проверки реального поведения приложения в среде, максимально приближенной к продуктивной.
- **`@WebMvcTest`**: Специализированная аннотация для тестирования MVC контроллеров, которая загружает только необходимые для контроллера компоненты, такие как конвертеры и валидаторы, без запуска полного контекста Spring.

### 3. Настройка и использование `MockMvc`

- **`.perform(RequestBuilder requestBuilder)`**: Основной метод для отправки HTTP-запросов. `RequestBuilder` создается для имитации различных HTTP-запросов, как `get()`, `post()` и др.
- **`.andExpect(ResultMatcher matcher)`**: Метод для проверки ответов контроллера. Позволяет проверить статус ответа, содержимое ответа, заголовки и другие аспекты.

### 4. Проверка результатов

- **`status()`**: Проверка статуса HTTP-ответа, например, успешен ли он (`isOK()`) или привел ли к ошибке (`isBadRequest()`).
- **`jsonPath(String expression, Matcher<?> matcher)`**: Используется для проверки конкретных данных в JSON-ответе, например, содержит ли поле `name` в ответе ошибку валидации.

### 5. Обработка исключений и мокирование

- **`@MockBean`**: Аннотация для добавления моков в контекст Spring теста. Позволяет заменить реальные бины на подделки для контроля поведения зависимостей.
- **`when()` и `thenReturn()`**: Методы из библиотеки Mockito для настройки поведения моков. Например, можно настроить мок сервиса так, чтобы при вызове метода возвращалось исключение или специфический результат.

Эти методы и подходы позволяют гибко настраивать тестирование контроллеров в Spring Boot, обеспечивая как широкое покрытие функциональности, так и детализированную проверку каждого аспекта взаимодействия клиента с сервером.


 







