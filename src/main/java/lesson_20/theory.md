# Lesson 20


### Загрузка файлов в Spring Boot

В Spring Boot загрузка и выгрузка файлов обычно выполняются с помощью Spring MVC, используя контроллеры.
Для этих задач можно использовать встроенную поддержку обработки многокомпонентных (multipart) файлов.

#### Конфигурация MultipartResolver

Spring Boot автоматически настраивает `MultipartResolver`, если в classpath присутствует соответствующая библиотека. Однако, вы можете настроить параметры загрузки файлов в `application.properties` или `application.yml`:

```properties
spring.servlet.multipart.max-file-size=2MB
spring.servlet.multipart.max-request-size=2MB
```


### Path

`Path` в Java представляет собой интерфейс, который является частью пакета `java.nio.file` и используется для представления пути к файлу или директории в файловой системе.
Он предоставляет более современный и гибкий подход к работе с файловыми путями по сравнению с классом `File` из `java.io`.
`Path` позволяет выполнять множество операций, таких как извлечение имени файла, родительской директории,
проверка существования файла и чтение атрибутов файла без открытия файла. Используя `Path`, можно создавать новые пути,
объединять их с другими путями, удалять избыточные элементы и преобразовывать относительные пути в абсолютные.
`Path` работает в тесной связке с другими классами в `java.nio.file`, такими как `Files` и `FileSystem`,
которые предоставляют дополнительные методы для работы с файлами и директориями. С помощью `Path` можно также наблюдать
за изменениями в файловой системе через `WatchService`. Методы вроде `resolve` и `normalize` обеспечивают удобные средства
для работы с путями в контексте файловой системы.

### Resource

`Resource` — это интерфейс в Spring Framework, предназначенный для абстрактной работы с низкоуровневыми ресурсами.
Он позволяет обеспечить универсальный доступ к различным источникам данных, будь то файл на диске, ресурс в JAR-файле,
или файл по сетевому адресу. `Resource` предоставляет методы для получения `InputStream`, что делает возможным чтение
содержимого ресурса независимо от его фактического местоположения. Он также позволяет проверять, существует ли ресурс,
и получать информацию о нём, такую как URL или URI. Spring автоматически использует соответствующую реализацию `Resource`
в зависимости от синтаксиса URI, который вы используете. Этот интерфейс находит применение во многих частях Spring,
включая загрузку конфигурационных файлов и ресурсов шаблонов. `Resource` облегчает работу с ресурсами в приложениях,
предоставляя единый API для работы с разнообразными источниками данных.

### UrlResource

`UrlResource` — это конкретная реализация интерфейса `Resource` в Spring Framework, которая предназначена для доступа к ресурсам по URL.
Этот класс оборачивает `java.net.URL`, предоставляя доступ к ресурсам, которые могут быть доступны через стандартные протоколы,
такие как HTTP, HTTPS, FTP, и файловые системы. `UrlResource` полезен в ситуациях, когда ресурсы должны быть загружены из внешнего
источника или когда необходимо взаимодействовать с ресурсами, которые доступны через сетевой протокол.
Он поддерживает различные операции, включая проверку существования ресурса, получение `InputStream` для чтения данных и
получение информации о ресурсе, такой как его `URI` или `URL`. `UrlResource` часто используется в веб-приложениях для загрузки
контента из интернета или доступа к файлам в локальной файловой системе через URL

. Также он может использоваться для интеграции с другими веб-сервисами, предоставляя гибкий и мощный способ работы с внешними ресурсами.

### MultipartFile

`MultipartFile` — это интерфейс в Spring Framework, используемый для представления загруженного файла в многокомпонентной (multipart) форме.
Этот интерфейс облегчает обработку загруженных файлов в веб-приложениях, предоставляя методы для получения имени файла, его содержимого,
размера и типа контента. `MultipartFile` применяется в контроллерах Spring MVC, где файлы загружаются пользователем через веб-формы.
С помощью `getBytes()` можно извлечь содержимое файла в виде массива байтов, а `getInputStream()` позволяет прочитать содержимое файла
как поток данных. `MultipartFile` также поддерживает методы для сохранения файла напрямую в файловую систему с использованием `transferTo()`.
Этот интерфейс широко используется в приложениях, где требуется обработка файлов, загруженных пользователями, например, в сервисах обмена
фотографиями или документами. Он обеспечивает безопасную и эффективную обработку файловых данных, управляя сложностями, связанными с
многокомпонентной загрузкой файлов.

### RedirectAttributes

`RedirectAttributes` — это специализированный тип данных в Spring MVC, который используется для передачи атрибутов в перенаправленных
запросах. Этот интерфейс позволяет сохранять атрибуты в течение одного редиректа, что полезно при реализации шаблона Post/Redirect/Get,
обеспечивая, чтобы параметры или сообщения об ошибках не терялись между запросами. `RedirectAttributes` обычно используется для добавления атрибутов,
которые должны быть доступны после перенаправления клиента на другой URL, например, сообщения о успешной загрузке файла или ошибке.
С помощью методов `addFlashAttribute` можно добавить данные, которые будут автоматически удалены после того, как они будут использованы в
следующем запросе, что предотвращает дублирование информации при обновлении страницы. `RedirectAttributes` интегрирован в Spring MVC и работает
в сочетании с `RedirectView`, облегчая разработчикам управление состоянием приложения между перенаправлениями.
Этот механизм особенно важен в веб-приложениях, где необходимо поддерживать состояние без использования сессии или сохранения состояния на стороне клиента.



## 01. Загрузка файлов

*
* Если загружать все файлы пользователей, то сильно возрастает нагрузка на сервер
   * Потому что все запросы на получение файлов будут проходить через нас
   * Также, файлы будут занимать очень много места и вам скоро его не хватит

* Целесообразно это переложить на сторонние решения, по типу - `Dropbox`, `AWS S3`, `Digital Ocean Spaces`

* Это облачные хранилища с возможностями быстрой доставки контента (безграничная память и высокая скорость)
* Преимущество стороннего решения в очень высокой скорости доставки контента без нагрузки вашего сервера

## 02. Типовая загрузка файлов в локальное хранилище

```
    @PostMapping("/api/files")
    public StandardResponseDto upload(@RequestParam("file") MultipartFile file) {
        String originalFileName = file.getOriginalFilename(); // получаем имя файла оригинальное

        String extension;

        if (originalFileName != null) {
            extension = originalFileName.substring(originalFileName.lastIndexOf(".") + 1); // забираем расширение файла
        } else {
            throw new IllegalArgumentException("null original file name");
        }

        String uuid = UUID.randomUUID().toString(); // генерируем случайную строку в формате UUID
        String newFileName = uuid + "." + extension; // создаем новое имя файла, которое состоит из случайной строки и расширения

        try (InputStream inputStream = file.getInputStream()) { // открываем у загружаемого файла поток для чтения
            Files.copy(inputStream, Path.of("C:\\Users\\marse\\Desktop\\OnlineShop\\static\\" + newFileName)); // перекидываем данные из потока для чтения
            // к нам на диск
        } catch (IOException e) {
            throw new IllegalStateException(e);
        }

        return StandardResponseDto.builder()
                .message(newFileName)
                .build();
    }
```
## 03. Подключение S3/DigitalOcean

```xml
<dependency>
  <groupId>com.amazonaws</groupId>
  <artifactId>aws-java-sdk-s3</artifactId>
  <version>1.12.572</version>
</dependency>
```

* `sdk3-s3` - значительно упрощает работу с сервисом


Перенос хранения файлов из локальной среды на внешнее облачное хранилище, такое как Digital Ocean Spaces, предоставляет ряд преимуществ, даже если файлы изначально загружаются через ваш сервер. Вот некоторые из ключевых преимуществ:

1. **Масштабируемость**: Облачные хранилища легко масштабируются. Вам не придется беспокоиться о достаточности дискового пространства на вашем сервере, так как можно легко увеличить объем хранения в облаке в зависимости от нужд.

2. **Надежность и доступность**: Облачные хранилища обеспечивают высокую степень доступности и надежности данных. Ваши файлы будут размещены в дата-центрах, которые гарантируют их сохранность даже в случае сбоя вашего физического сервера.

3. **Безопасность**: Провайдеры облачных услуг обычно предлагают расширенные возможности безопасности, такие как шифрование данных во время передачи и хранения, а также различные опции для управления доступом и аудита.

4. **Снижение затрат**: Хранение данных в облаке может быть более экономичным по сравнению с управлением собственной инфраструктурой хранения. Вы платите только за то, что используете, и избавляетесь от затрат на обслуживание и амортизацию физических серверов.

5. **Управление и обслуживание**: Облачные провайдеры берут на себя всю тяжесть управления и поддержки хранилища, что позволяет вам сконцентрироваться на развитии вашего приложения.

6. **Глобальный доступ**: Файлы, размещенные в облаке, могут быть легко доступны из любой точки мира, что улучшает производительность для пользователей, расположенных далеко от вашего основного сервера.

7. **Бэкап и восстановление**: Многие облачные сервисы предлагают встроенные решения для резервного копирования и восстановления, что повышает устойчивость вашего приложения к потере данных.

Чтобы интегрировать хранение в облаке Digital Ocean с вашим Spring Boot приложением, вы можете использовать библиотеки и SDK, предоставляемые Digital Ocean, или сторонние библиотеки, поддерживающие S3-совместимые API (поскольку Digital Ocean Spaces совместим с API S3).
Это позволит вашему приложению работать с облачным хранилищем так же, как с любым другим S3-совместимым хранилищем.


## Переменные окружения в Spring Boot

Это параметры конфигурации, которые управляют поведением приложения в различных средах (разработка, тестирование, продакшн).
Они представляют собой внешний способ передачи конфигурационных данных в приложение, что позволяет избежать хардкода значений непосредственно в коде.

### Как использовать переменные окружения в Spring Boot

1. **Определение переменных окружения:**
   Переменные окружения могут быть определены в операционной системе или в конфигурационных файлах CI/CD. Например, в Unix-подобных системах вы можете задать переменную окружения в терминале:
   ```bash
   export DATABASE_URL="jdbc:mysql://localhost:3306/mydb"
   ```

2. **Доступ к переменным окружения в приложении:**
   В Spring Boot для доступа к переменным окружения можно использовать аннотацию `@Value`. Например:
   ```java
   @Component
   public class MyComponent {
       @Value("${DATABASE_URL}")
       private String databaseUrl;

       // использование databaseUrl в коде
   }
   ```

3. **Использование `application.properties` или `application.yml`:**
   Вы можете задать значения по умолчанию в этих файлах, которые будут перезаписаны значениями из переменных окружения при необходимости:
   ```properties
   # application.properties
   DATABASE_URL=jdbc:h2:mem:testdb
   ```

   ```yaml
   # application.yml
   DATABASE_URL: jdbc:h2:mem:testdb
   ```

### Нюансы использования переменных окружения в Spring Boot

1. **Приоритеты конфигурации:**
   Spring Boot использует строгую иерархию для определения приоритета конфигурационных данных. Переменные окружения имеют один из самых высоких приоритетов, что позволяет им перезаписывать значения, заданные в `application.properties` или `application.yml`.

2. **Безопасность:**
   Старайтесь не хранить чувствительные данные, такие как пароли или секреты API, прямо в переменных окружения. Используйте для этого защищенные хранилища, например, Spring Cloud Config или HashiCorp Vault.

3. **Профили Spring:**
   Вы можете определить различные профили для разных сред, используя `spring.profiles.active` и определяя переменные окружения для каждой среды соответственно. Это позволяет гибко управлять конфигурацией для различных условий развертывания.

4. **Передача сложных структур данных:**
   Если вам нужно передать сложные структуры данных через переменные окружения, подумайте о форматировании их как строк, возможно, в JSON-формате, который затем можно разобрать в приложении.

Использование переменных окружения улучшает безопасность и упрощает управление конфигурациями приложения, делая его более гибким и адаптируемым к изменениям среды.

При запуске приложения на Spring Boot переменные окружения можно задать несколькими способами в зависимости от среды и способа запуска. Вот несколько основных методов:

### 1. В командной строке
Вы можете установить переменные окружения прямо перед запуском приложения в командной строке. Это работает на любой операционной системе.

**На UNIX-подобных системах (Linux, macOS):**
```bash
export DATABASE_URL="jdbc:mysql://localhost:3306/mydb"
java -jar myapp.jar
```

**На Windows:**
```cmd
set DATABASE_URL=jdbc:mysql://localhost:3306/mydb
java -jar myapp.jar
```

### 2. При запуске через Maven или Gradle
Если вы используете Maven или Gradle для запуска вашего приложения во время разработки, вы можете указать переменные окружения в конфигурации плагина.

**Для Maven:**
```xml
<plugin>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-maven-plugin</artifactId>
    <configuration>
        <environmentVariables>
            <DATABASE_URL>jdbc:mysql://localhost:3306/mydb</DATABASE_URL>
        </environmentVariables>
    </configuration>
</plugin>
```
Затем запускаете:
```bash
mvn spring-boot:run
```

**Для Gradle:**
```groovy
bootRun {
    environment "DATABASE_URL", "jdbc:mysql://localhost:3306/mydb"
}
```
Затем запускаете:
```bash
./gradlew bootRun
```

### 3. В файле конфигурации IDE
Если вы используете IDE, такие как IntelliJ IDEA или Eclipse, вы можете установить переменные окружения в настройках конфигурации запуска вашего приложения.

**В IntelliJ IDEA:**
- Откройте конфигурацию запуска (Run/Debug Configurations).
- Найдите раздел "Environment variables" и установите нужные переменные.

**В Eclipse:**
- Откройте конфигурацию запуска (Run Configurations).
- Во вкладке "Environment" добавьте необходимые переменные окружения.

### 4. В Docker или Kubernetes
При запуске приложений в контейнерах (например, с использованием Docker или Kubernetes) вы также можете задать переменные окружения через конфигурацию контейнера.

**Docker:**
```dockerfile
FROM openjdk:11
COPY target/myapp.jar myapp.jar
ENV DATABASE_URL jdbc:mysql://localhost:3306/mydb
ENTRYPOINT ["java", "-jar", "myapp.jar"]
```

**Kubernetes:**
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: myapp
spec:
  containers:
  - name: myapp
    image: myapp:latest
    env:
    - name: DATABASE_URL
      value: "jdbc:mysql://localhost:3306/mydb"
```

Эти методы позволяют гибко управлять конфигурацией приложения, адаптируя её под разные среды и условия запуска.

## Тестирование контроллеров в Spring Boot

Тестирование контроллеров в Spring Boot обычно включает использование фреймворка `MockMvc`, который позволяет отправлять HTTP-запросы на контроллеры и проверять ответы без запуска полноценного сервера. Вот подробное объяснение основных методов и подходов:

### 1. Инициализация `MockMvc`

- **`MockMvcBuilders.standaloneSetup`**: Этот метод используется для создания конфигурации `MockMvc` для тестирования одного или нескольких контроллеров в изоляции от остальной части приложения. Это идеально подходит для модульного тестирования, так как не требуется загружать полный контекст Spring.
- **`MockMvcBuilders.webAppContextSetup`**: Этот метод требует загрузки полного веб-контекста приложения, что делает его подходящим для интеграционных тестов.

### 2. Конфигурация тестов

- **`@SpringBootTest`**: Эта аннотация используется для загрузки полноценного контекста приложения и применяется в интеграционных тестах, подходит для проверки реального поведения приложения в среде, максимально приближенной к продуктивной.
- **`@WebMvcTest`**: Специализированная аннотация для тестирования MVC контроллеров, которая загружает только необходимые для контроллера компоненты, такие как конвертеры и валидаторы, без запуска полного контекста Spring.

### 3. Настройка и использование `MockMvc`

- **`.perform(RequestBuilder requestBuilder)`**: Основной метод для отправки HTTP-запросов. `RequestBuilder` создается для имитации различных HTTP-запросов, как `get()`, `post()` и др.
- **`.andExpect(ResultMatcher matcher)`**: Метод для проверки ответов контроллера. Позволяет проверить статус ответа, содержимое ответа, заголовки и другие аспекты.

### 4. Проверка результатов

- **`status()`**: Проверка статуса HTTP-ответа, например, успешен ли он (`isOK()`) или привел ли к ошибке (`isBadRequest()`).
- **`jsonPath(String expression, Matcher<?> matcher)`**: Используется для проверки конкретных данных в JSON-ответе, например, содержит ли поле `name` в ответе ошибку валидации.

### 5. Обработка исключений и мокирование

- **`@MockBean`**: Аннотация для добавления моков в контекст Spring теста. Позволяет заменить реальные бины на подделки для контроля поведения зависимостей.
- **`when()` и `thenReturn()`**: Методы из библиотеки Mockito для настройки поведения моков. Например, можно настроить мок сервиса так, чтобы при вызове метода возвращалось исключение или специфический результат.

Эти методы и подходы позволяют гибко настраивать тестирование контроллеров в Spring Boot, обеспечивая как широкое покрытие функциональности, так и детализированную проверку каждого аспекта взаимодействия клиента с сервером.



