# Lesson 08


## JPA (Java Persistence API)

JPA (Java Persistence API) - это спецификация Java EE, которая описывает стандартный способ работы с системами управления реляционными базами данных (СУБД) в Java-приложениях. JPA упрощает разработку приложений, работающих с базами данных, позволяя разработчикам работать с объектами Java вместо написания SQL-запросов.

**Основные функции JPA:**

1. **Связывание объектов с базой данных:** JPA позволяет связать объекты Java с таблицами в базе данных, что упрощает сохранение, извлечение и изменение данных через Java-объекты.

2. **Управление жизненным циклом объектов:** JPA управляет жизненным циклом объектов, включая их создание, сохранение, загрузку и удаление из базы данных.

3. **Кэширование данных:** JPA предоставляет возможность кэширования данных, что снижает количество запросов к базе данных и улучшает производительность приложения.

4. **Язык запросов:** JPA предлагает объектно-ориентированный язык запросов (JPQL), позволяющий создавать запросы к базе данных.

5. **Транзакционность:** JPA поддерживает транзакции, обеспечивая целостность данных в базе данных при выполнении операций.

JPA также предоставляет различные аннотации и API для управления связью между объектами Java и таблицами в базе данных, что значительно упрощает разработку приложений, снижает объем кода и повышает производительность.

**Основы JPA и ORM:**

Принцип работы JPA основан на объектно-реляционном отображении (ORM), которое связывает Java-объекты с таблицами в базе данных. ORM позволяет разработчикам работать с базой данных через объекты и классы, значительно упрощая код и процесс разработки.

**Hibernate и его возможности:**

Hibernate — это одна из самых популярных реализаций JPA, предоставляющая мощные инструменты для работы с ORM. Hibernate позволяет создавать CRUD-приложения, управлять пользователями и объектами, такими как автомобили, автоматически удаляя "бесхозные" записи из базы данных.

**Преимущества использования Hibernate:**

1. **Автоматическая генерация SQL-запросов:** Hibernate генерирует SQL-запросы на основе маппинга сущностей, что упрощает взаимодействие с базой данных.

2. **Поддержка различных баз данных:** Hibernate обеспечивает абстракцию от конкретной СУБД, что упрощает переносимость приложений.

3. **Кэширование данных:** Hibernate поддерживает кэширование на уровне объектов и запросов, повышая производительность приложения.

4. **Управление транзакциями:** Hibernate интегрируется с менеджерами транзакций, обеспечивая целостность данных.

5. **Ленивая загрузка данных:** Позволяет загружать связанные данные по мере необходимости, что улучшает производительность.

6. **Расширяемость и гибкость:** Hibernate поддерживает пользовательские типы данных, аннотации и XML-конфигурации.

7. **Управление состоянием объектов:** Hibernate отслеживает изменения состояния объектов и синхронизирует их с базой данных.

8. **Транзакционная безопасность:** Обеспечивает выполнение операций в рамках транзакций, защищая данные от ошибок.

9. **Инструменты для отладки и профилирования:** Предоставляет инструменты для анализа и оптимизации запросов.

10. **Интеграция с другими технологиями:** Hibernate легко интегрируется с Java EE, Spring Framework и Spring Boot.

11. **Облегчение тестирования:** Поддержка тестовой среды базы данных облегчает модульное и интеграционное тестирование.

12. **Богатая документация и сообщество:** Обширная документация и активное сообщество разработчиков обеспечивают поддержку и помощь при работе с Hibernate.

Использование Hibernate в связке с JPA предоставляет разработчикам мощный и гибкий инструмент для работы с базами данных, улучшая производительность, упрощая разработку и поддерживая совместимость с JPA.




**Java Persistence API (JPA), Hibernate и ORM**

Java Persistence API (JPA) является частью спецификации Java EE, предоставляющей стандартизированный способ работы с реляционными базами данных в Java-приложениях. Это API облегчает разработку, позволяя инженерам манипулировать объектами Java вместо прямого взаимодействия с SQL, способствуя повышению эффективности и сокращению кода.

**Основные функции JPA:**

1. **Маппинг объектов:** JPA позволяет связывать Java-объекты с таблицами баз данных, автоматизируя процесс сохранения, извлечения, обновления и удаления данных (CRUD).
2. **Управление жизненным циклом объектов:** JPA управляет состоянием объектов от создания до удаления, обеспечивая их синхронизацию с базой данных.
3. **Кэширование:** Уменьшает количество запросов к базе данных, улучшая производительность приложений.
4. **Язык запросов JPQL:** Позволяет формировать запросы к базе данных, используя объектно-ориентированный подход.
5. **Транзакционность:** Поддерживает группировку операций в единую транзакцию для обеспечения целостности данных.


**Основные концепции ORM и JPA:**

ORM облегчает преобразование данных между несовместимыми типами систем, позволяя объектам в коде отображаться на таблицы в базе данных и наоборот. В JPA это достигается через:

- **Сущности (Entities):** Классы в Java, аннотированные как `@Entity`, соответствуют таблицам в базе данных. Атрибуты класса отображаются на столбцы таблиц.
- **EntityManager:** Основной интерфейс JPA, управляющий жизненным циклом сущностей, включая операции, такие как сохранение, удаление и запросы к данным.
- **Persistence Unit:** Определяется в `persistence.xml`, управляет конфигурацией JPA и областью видимости, в которой сущности управляются.

**Hibernate как реализация JPA:**

Hibernate расширяет функциональность JPA, предоставляя более детальное управление маппингом и конфигурацией, что улучшает взаимодействие с базой данных и производительность приложения.

**Конфигурация Hibernate:**

Hibernate, реализация JPA, может быть настроена как через XML, так и через аннотации:

- **XML-конфигурация (hibernate.cfg.xml):** Определяет параметры подключения к базе данных, выбор диалекта SQL, стратегию DDL и другие настройки. Маппинг-файлы также могут быть указаны для определения отношений между классами и таблицами.

  ```xml
  <hibernate-configuration>
    <session-factory>
      <property name="hibernate.dialect">org.hibernate.dialect.PostgreSQLDialect</property>
      <property name="hibernate.connection.url">jdbc:postgresql://localhost/mydatabase</property>
      <!-- Другие свойства -->
    </session-factory>
  </hibernate-configuration>
  ```

- **Аннотации:** Предоставляют интуитивно понятный способ маппинга классов и их атрибутов на таблицы и столбцы баз данных, делая конфигурацию более наглядной и сопровождаемой.

  ```java
  @Entity
  @Table(name = "users")
  public class User {
      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;

      @Column(name = "username")
      private String username;
      // Остальные поля и методы
  }
  ```

**Применение JPA и Hibernate:**

Интеграция JPA и Hibernate в Java-приложения обеспечивает разработчикам мощный набор инструментов для работы с реляционными базами данных, позволяя сосредоточиться на объектной модели и логике приложения, а не на деталях реализации базы данных.


Spring Boot JPA (Java Persistence API) является частью большего семейства Spring Data и предоставляет удобные инструменты для работы с базами данных в Java-приложениях. Вот основные моменты, которые помогут понять, что это такое и как это работает:

1. **Что такое Spring Boot JPA?**
    - Spring Boot JPA – это модуль в Spring Boot, который упрощает интеграцию слоя доступа к данным, используя JPA (Java Persistence API). JPA – это спецификация Java, предоставляющая стандартизированный способ управления данными в базе данных в Java-приложениях.
    - Spring Boot JPA облегчает конфигурацию и управление базами данных, автоматически настраивая JPA и упрощая создание репозиториев для взаимодействия с базой данных.

2. **Как работает Spring Boot JPA?**
    - **Автоконфигурация:** В Spring Boot автоматически конфигурируются компоненты, необходимые для работы с базой данных, такие как `EntityManagerFactory`, `DataSource` и транзакционные менеджеры. Это означает, что разработчикам не нужно тратить время на ручную настройку.
    - **Репозитории:** Spring Boot JPA позволяет создавать репозитории, интерфейсы для взаимодействия с базой данных, с минимальным количеством кода. Разработчики могут определить интерфейсы, расширяющие `JpaRepository` или другие подобные интерфейсы Spring Data, и Spring автоматически создаст их реализацию во время выполнения.
    - **Объектно-реляционное отображение (ORM):** JPA использует ORM для отображения объектов Java на таблицы базы данных, позволяя разработчикам работать с базой данных с помощью объектно-ориентированных парадигм.
    - **JPQL и SQL:** JPA позволяет использовать Java Persistence Query Language (JPQL) или нативный SQL для выполнения запросов к базе данных, давая разработчикам гибкость в выборе подхода к взаимодействию с данными.

3. **Пример использования:**
    - Предположим, у вас есть класс `User`, который вы хотите отобразить на таблицу в базе данных.
    - Вы создаёте интерфейс `UserRepository`, расширяющий `JpaRepository`, и автоматически получаете множество методов для работы с пользователями, таких как сохранение, удаление, поиск и т.д., без необходимости писать дополнительный код.

Для работы с Spring Data JPA и для определения сущностей, их связей и репозиториев, используются различные аннотации из пакетов `javax.persistence` и `org.springframework`. Вот некоторые из наиболее важных аннотаций, которые часто используются в приложениях Spring Data JPA:

1. **Аннотации сущностей:**
    - `@Entity`: Определяет класс как сущность JPA, которая должна быть отображена в таблицу базы данных.
    - `@Table`: Указывает на то, с какой таблицей в базе данных ассоциирована сущность. Можно указать имя таблицы и другие детали.
    - `@Id`: Обозначает поле класса как первичный ключ сущности.
    - `@GeneratedValue`: Определяет стратегию генерации значений для первичного ключа.
    - `@Column`: Определяет отображение поля класса на столбец таблицы в базе данных. Можно указать имя столбца, его длину, уникальность и другие параметры.
    - `@ManyToOne`, `@OneToMany`, `@OneToOne`, `@ManyToMany`: Определяют различные типы связей между сущностями.

2. **Аннотации репозитория:**
    - `@Repository`: Помечает интерфейс как репозиторий, что также помогает в обработке исключений переводя их в исключения Spring DataAccessException.
    - `@Transactional`: Определяет область, в пределах которой должна быть гарантирована целостность выполнения операций. Может быть применена к классу или методу.

3. **Дополнительные аннотации:**
    - `@Query`: Позволяет определить пользовательский запрос на языке JPQL или нативный SQL.
    - `@Param`: Указывает параметр в пользовательском запросе, обозначенном через `@Query`.
    - `@PersistenceContext`: Используется для внедрения `EntityManager` в DAO-классы.

Эти аннотации играют ключевую роль в маппинге объектов Java на таблицы базы данных и обеспечивают удобный способ взаимодействия с данными, минимизируя необходимость написания шаблонного кода.


### `@Query` и `@Param`

Аннотация `@Query` используется для определения пользовательского запроса на языке JPQL или SQL. Аннотация `@Param` используется для указания параметров в этих запросах.

```java
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import java.util.List;

public interface UserRepository extends JpaRepository<User, Long> {

    // Пример JPQL запроса с параметром
    @Query("SELECT u FROM User u WHERE u.email = :email")
    List<User> findByEmail(@Param("email") String email);

    // Пример нативного SQL запроса с параметром
    @Query(value = "SELECT * FROM users u WHERE u.name = :name", nativeQuery = true)
    List<User> findByName(@Param("name") String name);
}
```

В этом примере, `findByEmail` использует JPQL для поиска пользователей по электронной почте, а `findByName` использует нативный SQL для поиска пользователей по имени.

### Варианты запросов:

В Spring Data JPA можно использовать несколько типов запросов:

1. **JPQL (Java Persistence Query Language):** Позволяет создавать запросы, ориентированные на сущности и их отношения, а не на таблицы и столбцы базы данных.

2. **Нативный SQL (nativeQuery):** Предоставляет возможность писать прямые SQL-запросы, что может быть полезно для использования функций, специфичных для конкретной базы данных, или когда операции не могут быть легко выражены через JPQL.

3. **Методы Spring Data JPA:** Названия методов в репозиториях могут быть автоматически трансформированы в запросы без необходимости явно их указывать, например, `findByLastName(String lastName)`.







Spring Boot JPA (Java Persistence API) является частью большего семейства Spring Data и предоставляет удобные инструменты для работы с базами данных в Java-приложениях. Вот основные моменты, которые помогут понять, что это такое и как это работает:

1. **Что такое Spring Boot JPA?**
    - Spring Boot JPA – это модуль в Spring Boot, который упрощает интеграцию слоя доступа к данным, используя JPA (Java Persistence API). JPA – это спецификация Java, предоставляющая стандартизированный способ управления данными в базе данных в Java-приложениях.
    - Spring Boot JPA облегчает конфигурацию и управление базами данных, автоматически настраивая JPA и упрощая создание репозиториев для взаимодействия с базой данных.

2. **Как работает Spring Boot JPA?**
    - **Автоконфигурация:** В Spring Boot автоматически конфигурируются компоненты, необходимые для работы с базой данных, такие как `EntityManagerFactory`, `DataSource` и транзакционные менеджеры. Это означает, что разработчикам не нужно тратить время на ручную настройку.
    - **Репозитории:** Spring Boot JPA позволяет создавать репозитории, интерфейсы для взаимодействия с базой данных, с минимальным количеством кода. Разработчики могут определить интерфейсы, расширяющие `JpaRepository` или другие подобные интерфейсы Spring Data, и Spring автоматически создаст их реализацию во время выполнения.
    - **Объектно-реляционное отображение (ORM):** JPA использует ORM для отображения объектов Java на таблицы базы данных, позволяя разработчикам работать с базой данных с помощью объектно-ориентированных парадигм.
    - **JPQL и SQL:** JPA позволяет использовать Java Persistence Query Language (JPQL) или нативный SQL для выполнения запросов к базе данных, давая разработчикам гибкость в выборе подхода к взаимодействию с данными.

3. **Пример использования:**
    - Предположим, у вас есть класс `User`, который вы хотите отобразить на таблицу в базе данных.
    - Вы создаёте интерфейс `UserRepository`, расширяющий `JpaRepository`, и автоматически получаете множество методов для работы с пользователями, таких как сохранение, удаление, поиск и т.д., без необходимости писать дополнительный код.


**Настройка JPA в Spring Boot:**

1. **Entity классы:** Это классы, которые отображаются на таблицы в базе данных и отмечаются аннотацией @Entity. Также используются аннотации для определения таблиц, столбцов и отношений между таблицами.

2. **Repository интерфейсы:** Эти интерфейсы расширяют JpaRepository и позволяют выполнять CRUD операции с базой данных.

3. **EntityManager:** Управляет жизненным циклом Entity объектов, выполняет CRUD операции и управляет транзакциями.

4. **Transaction Manager:** Обеспечивает целостность данных в базе данных, управляя транзакциями.

5. **DataSource:** Объект, предоставляющий доступ к базе данных, настраиваемый через файлы конфигурации или аннотации.


Для работы с Spring Data JPA и для определения сущностей, их связей и репозиториев, используются различные аннотации из пакетов `javax.persistence` и `org.springframework`. Вот некоторые из наиболее важных аннотаций, которые часто используются в приложениях Spring Data JPA:

1. **Аннотации сущностей:**
    - `@Entity`: Определяет класс как сущность JPA, которая должна быть отображена в таблицу базы данных.
    - `@Table`: Указывает на то, с какой таблицей в базе данных ассоциирована сущность. Можно указать имя таблицы и другие детали.
    - `@Id`: Обозначает поле класса как первичный ключ сущности.
    - `@GeneratedValue`: Определяет стратегию генерации значений для первичного ключа.
    - `@Column`: Определяет отображение поля класса на столбец таблицы в базе данных. Можно указать имя столбца, его длину, уникальность и другие параметры.
    - `@ManyToOne`, `@OneToMany`, `@OneToOne`, `@ManyToMany`: Определяют различные типы связей между сущностями.

2. **Аннотации репозитория:**
    - `@Repository`: Помечает интерфейс как репозиторий, что также помогает в обработке исключений переводя их в исключения Spring DataAccessException.
    - `@Transactional`: Определяет область, в пределах которой должна быть гарантирована целостность выполнения операций. Может быть применена к классу или методу.

3. **Дополнительные аннотации:**
    - `@Query`: Позволяет определить пользовательский запрос на языке JPQL или нативный SQL.
    - `@Param`: Указывает параметр в пользовательском запросе, обозначенном через `@Query`.
    - `@PersistenceContext`: Используется для внедрения `EntityManager` в DAO-классы.

Эти аннотации играют ключевую роль в маппинге объектов Java на таблицы базы данных и обеспечивают удобный способ взаимодействия с данными, минимизируя необходимость написания шаблонного кода.


### `@Query` и `@Param`

Аннотация `@Query` используется для определения пользовательского запроса на языке JPQL или SQL. Аннотация `@Param` используется для указания параметров в этих запросах.

```java
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import java.util.List;

public interface UserRepository extends JpaRepository<User, Long> {

    // Пример JPQL запроса с параметром
    @Query("SELECT u FROM User u WHERE u.email = :email")
    List<User> findByEmail(@Param("email") String email);

    // Пример нативного SQL запроса с параметром
    @Query(value = "SELECT * FROM users u WHERE u.name = :name", nativeQuery = true)
    List<User> findByName(@Param("name") String name);
}
```

В этом примере, `findByEmail` использует JPQL для поиска пользователей по электронной почте, а `findByName` использует нативный SQL для поиска пользователей по имени.

### Варианты запросов:

В Spring Data JPA можно использовать несколько типов запросов:

1. **JPQL (Java Persistence Query Language):** Позволяет создавать запросы, ориентированные на сущности и их отношения, а не на таблицы и столбцы базы данных.

2. **Нативный SQL (nativeQuery):** Предоставляет возможность писать прямые SQL-запросы, что может быть полезно для использования функций, специфичных для конкретной базы данных, или когда операции не могут быть легко выражены через JPQL.

3. **Методы Spring Data JPA:** Названия методов в репозиториях могут быть автоматически трансформированы в запросы без необходимости явно их указывать, например, `findByLastName(String lastName)`.


# Связи между сущностями

* ОО-связи
* Реляционные связи

## Рассмотрим предметную область:

* Владельцы машин
* Машины
* Водители машин (арендаторы машин)

## 01.  Реляционные связи (SQL)

### Один-ко-многим

* Как сделать так, чтобы у машины был владелец?
* Нам необходимо у машины хранить id владельца из таблицы `account`
* Такая связь называется `Многие-к-Одному`/`Many-To-One`, `Один-ко-Многим`/`One-To-Many`
* Почему так называется? Потому что у одного владельца может быть много машин, и у многих машин только один владелец
* Чтобы гарантировать, что у машины будет указан существующий владелец, необходимо использовать внешний ключ (`foreign key`)
* `foreign key (owner_id) references account(id)` - мы говорим, что колонка `owner_id` является внешним ключом
    * Ссылается на колонку `id` в таблице `account`
    * Вы не сможете поставить в колонку `owner_id` значение, которого нет в таблице `account`

### Многие-ко-многим

* Как сделать так, чтобы можно было обозначить, что какой-то человек водит какую-то машину, но не является владельцем
* Много человек могут "брать в аренду" много машин, и при этом много машин может быть арендовано многими людьми
* Такая связь называется `Многие-ко-многим`/`Many-to-Many`
* Ее в SQL можно реализовать с помощью третьей таблицы с двумя внешними ключами

## 02. Объектно-ориентированные связи

* А как сделать аналогию, только в приложении? Как правильно связать между собой классы?
* Важно помнить, что `класс ~ таблица`, а `объект ~ строка` таблицы.
* Как это реализуется?

### Один-ко-многим

* В классе, который "Один", нужно сделать множество/список объектов типа "Многие"
* В классе, который "Многие", нужно сделать один объект типа "Один"

### Многие ко многим

* В обоих классах создаем множества/списки другого типа

## 03. Реализация связей в образовательном центре

* Пользователь
    * Список курсов, на которые он записан
* Курс
    * Список уроков, которые включены в этот курс
    * Список студентов, которые включены в этот курс
* Урок
    * Курс, к которому принадлежит урок

### Многие-к-одному/Один-ко-многим

```
@ManyToOne
@JoinColumn(name = "course_id", nullable = false)
private Course course;
```

* `@ManyToOne` - аннотация `JPA`, которой бы обозначаем связь `Многие к одному`
* `@JoinColumn` - говорим, что нужно создать внешний ключ `course_id`
* Hibernate автоматически создаст внешний ключ на таблицу с курсами.

```
@OneToMany(mappedBy = "course")
private Set<Lesson> lessons;
```

* `@OneToMany` - аннотация JPA, которая ставится в связи "Один ко многим" в сущности, которая "одна"
* `mappedBy` - означает, что в дочерней сущности (в уроке) уже прописана логика этой связи над полем `course`
    * и мы просто хотим использовать ее
* В множество `lessons` будут автоматически загружаться уроки, у которых стоит тот же `course`, что вы и запросили

### Многие-ко-многим

```
@ManyToMany
    @JoinTable(
            name = "student_course",
            joinColumns =
            @JoinColumn(name = "student_id", nullable = false, referencedColumnName = "id"),
            inverseJoinColumns =
            @JoinColumn(name = "course_id", nullable = false, referencedColumnName = "id"),
            uniqueConstraints = @UniqueConstraint(columnNames = {"student_id", "course_id"})
    )
    private Set<Course> courses;
```

* `@ManyToMany` - обозначает связь многие-ко-многим
* `@JoinTable` - говорит о том, что нам нужна третья таблица `student_course` с двумя внешними ключами:
    * `joinColumns` - указываем первую колонку (первый внешний ключ), она не может null, называется `student_id` и ссылается на `id` таблицы `account`
    * `inverseJoinColumns` - указываем вторую колонку (второй внешний ключ), она не может быть null, называется `course_id` и ссылается на `id` таблицы `course`
    * `uniqueContstraints` - указываем колонки, которые должны быть в паре уникальными в этой таблице
* В чем разница между `joinColumns` и `uniqueContstraints`
* В `joinColumns` пишем ссылку на ту таблицу, из класса которой мы прописываем связь
* Сейчас мы описывали связь в классе `User`, поэтому первая колонка ссылается на `User`

## 04. Реализация endpoint-а для добавления урока в курс

* По правилам REST нужно endpoint назвать так:

```
POST /api/courses/{id-курса}/lessons

{
  "name": "Java - Введение",
  "startTime": "9:30",
  "finishTime": "13:00",
  "dayOfWeek": "MONDAY"
}
```

## 05. Реализация endpoint-а для получения всех уроков какого-либо курса

* По правилам REST можно endpoint назвать так:

```
GET /api/courses/{id-курса}/lessons
```

### Выводы

* Существуют связи "Многие-к-одному"/"Один-ко-многим" и "Многие-ко-многим"
* На уровне SQL-базы данных:
    * Многие-к-одному реализуются через один внешний ключ на другую таблицу
    * Многие-ко-многим с помощью третей таблицы с двумя внешними ключами
* На уровне Java-кода:
    * Многие-к-одному реализуются через `Set` в одном классе и через единственный экземпляр в другом.
    * Многие-ко-многим реализуются через `Set` в обоих классах
* Необходимо использовать соответствующие аннотации JPA для того, чтобы Hibernate мог сгенерировать необходимые таблицы и связи между ними:
    * `@OneToMany`/`@ManyToOne`/`@JoinColumn` - для один-ко-многим и многие-к-одному соответственно
    * `@ManyToMany/@JoinTable` - для многие-ко-многим
* Если мы хотим реализовать endpoint-ы для работы с этими сущностями, то их следует именовать вот так:
    * `/родительская сущность/{id-родительской сущности}/дочерняя сущность`
    * `/cars/10/drivers` - все водители машины с id = 10
    * `/drivers/5/cars` - все машины водителя с id = 5
    * `/courses/4/lessons` - все уроки четвертого курса и т.д.


