# Lesson 02


###  Многопоточность. Введение
### Общие сведения**

1. **Введение**
    - XX век ознаменовался появлением компьютеров в современном понимании.
    - Развитие технологий стимулировало уменьшение размеров ЭВМ и повышение их производительности и энергоэффективности.
    - Появление микросборок и микросхем.
    - Формулировка «закона» Мура, предсказывающего удвоение числа транзисторов на микросхемах каждые два года.

2. **Основные элементы в компьютере**
    - Процессор как ключевой элемент, исполняющий инструкции программ.
    - Развитие процессоров от одноядерных к многоядерным для увеличения производительности.

3. **Краткое описание работы процессора**
    - Арифметико-логическое устройство (АЛУ) как центральная часть процессора.
    - Регистры, шины данных и адреса, декодер инструкций.
    - Основные операции АЛУ и принципы их выполнения.

4. **Поддержка на уровне операционной системы**
    - ОС распределяет время процессора между процессами различными методами: простая смена задач, кооперативная и вытесняющая многозадачность.
    - Отличие кооперативной от вытесняющей многозадачности по методике распределения времени процессора.

5. **Концепции вычислений**
    - Последовательные вычисления, выполняющие задачи последовательно.
    - Параллельные вычисления, позволяющие обрабатывать множество задач одновременно на многоядерных процессорах.

6. **Процессы и потоки**
    - Определение и различие между процессом и потоком.
    - Процессы как независимые единицы с собственными ресурсами.
    - Потоки как подзадачи внутри процесса, использующие общие ресурсы.
    - Разница между потоками и процессами в контексте информации, использования памяти и скорости переключения.

7. **Многопоточность и алгоритм разделения времени**
    - Time-slicing как метод распределения времени процессора между потоками.
    - Отличие имитации параллельности в одноядерных системах от реальной параллельности в многоядерных.

8. **Преимущества и недостатки многопоточности**
    - Улучшение адаптивности и производительности приложений с помощью многопоточности.
    - Вызовы в дизайне и отладке многопоточных приложений.
    - Проблемы с синхронизацией данных и переключением контекстов между потоками.

9. **Закон Амдала**
    - Иллюстрация ограничений на увеличение производительности системы за счёт параллелизма.
    - Влияние непараллелизуемой части кода на общую производительность.

10. **Современные технологии многопоточности**
- Графические процессоры (GPU) и их роль в параллельных вычислениях.
- Применение многопоточности в облачных вычислениях и микросервисах.
- Использование многопоточности в больших данных и искусственном интеллекте.

#### Средства для работы с многопоточностью в Java

**Java 1.0**: В самой первой версии Java были представлены базовые средства для работы с потоками:
- Класс `Thread` для представления потоков выполнения.
- Интерфейс `Runnable` для определения кода, который может выполняться в потоке.
- Методы `wait()`, `notify()`, и `notifyAll()` в классе `Object` для взаимодействия между потоками.

**Java 1.2**: Введены улучшения в библиотеку коллекций, что косвенно повлияло на многопоточное программирование, например, введение потокобезопасных коллекций, таких как `Hashtable` и `Vector`.

**Java 1.5 (Java 5)**: Версия Java 5 стала значительным шагом в развитии многопоточности:
- Пакет `java.util.concurrent` представил множество новых конструкций для многопоточного программирования, включая `ExecutorService`, `CyclicBarrier`, `Semaphore`, `ConcurrentHashMap` и другие.
- Введены новые возможности для управления блокировками через классы `Lock` и `ReentrantLock`.
- Добавлены атомарные классы в пакете `java.util.concurrent.atomic`, предоставляющие операции без блокировок на одиночных переменных.

**Java 1.8 (Java 8)**: Введение `CompletableFuture`, который предлагает новый способ работы с асинхронным программированием и комбинированием асинхронных операций. Появление лямбда-выражений также упростило использование некоторых аспектов многопоточности.

#### Модели многопоточных программ
- Синхронизация, блокировки, `volatile`.
- Транзакционная память, рекурсивный параллелизм.
- Модель акторов: взаимодействие объектов-акторов через обмен сообщениями.

#### Проблемы, решаемые многопоточностью (продолжение)

1. **Одновременное выполнение нескольких действий**: Многопоточность улучшает интерактивность и отзывчивость приложений.
2. **Ускорение вычислений**: Эффективное распределение задач по ядрам процессора сокращает время выполнения.

#### Проблемы, создаваемые многопоточностью

1. **Взаимная блокировка (Deadlock)**: Ситуация, когда потоки в ожидании ресурсов, занятых другими потоками, не могут продолжить работу.
2. **Состояние гонки (Race Condition)**: Ошибка, приводящая к зависимости системы от последовательности выполнения потоков.

#### Что должен знать Java-разработчик о многопоточности

**Уровень Junior**:
- Основы многопоточности в Java.
- Синтаксис для работы с потоками.
- Основы `java.util.concurrent`.

**Уровень Middle**:
- Глубокое понимание инструментов Java для многопоточности.
- Многопоточность в контексте Spring.
- Разработка многопоточных функций.

**Уровень Senior**:
- Продвинутые знания инструментов и библиотек для многопоточности.
- Применение многопоточности в различных сценариях.
- Архитектурная интеграция многопоточности в приложения.


###  **Процессы и потоки**
    - Определение и различие между процессом и потоком.
    - Процессы как независимые единицы с собственными ресурсами.
    - Потоки как подзадачи внутри процесса, использующие общие ресурсы.
    - Разница между потоками и процессами в контексте информации, использования памяти и скорости переключения.


###  **Создание и запуск потоков в Java**
В Java потоки можно создавать двумя способами: наследуясь от класса `Thread` или реализуя интерфейс `Runnable`.

- **Пример с наследованием от класса Thread:**

  ```java
  class MyThread extends Thread {
      public void run() {
          System.out.println("Поток запущен: " + Thread.currentThread().getName());
      }
  }

  public class Main {
      public static void main(String[] args) {
          MyThread thread = new MyThread();
          thread.start();
      }
  }
  ```

- **Пример с реализацией интерфейса Runnable:**

  ```java
  class MyRunnable implements Runnable {
      public void run() {
          System.out.println("Поток запущен: " + Thread.currentThread().getName());
      }
  }

  public class Main {
      public static void main(String[] args) {
          Thread thread = new Thread(new MyRunnable());
          thread.start();
      }
  }
  ```


###  **Управление потоками:**
- Метод `start()` запускает поток, в то время как вызов `run()` просто выполняет код в текущем потоке.
- Можно устанавливать приоритеты потоков, используя метод `setPriority()`, что влияет на распределение времени процессора между потоками.
- Потоки-демоны (`daemon threads`) — это служебные потоки, которые не препятствуют завершению работы JVM.
- Метод `join()` позволяет одному потоку ожидать завершения работы другого потока.
- Приостановка выполнения потока может быть реализована с помощью `Thread.sleep()`


### Метод join() в Java

#### Введение в join()
Метод `join()` в Java позволяет одному потоку ожидать завершения другого потока. Это особенно полезно в многопоточных программах, где один поток должен дождаться завершения других потоков перед продолжением выполнения. Этот метод блокирует текущий поток до тех пор, пока целевой поток, на котором был вызван `join()`, не завершится.

#### Примеры использования метода join()

##### Пример 1: Синхронизация счетчика
```java
class Counter {
    private int count = 0;

    public synchronized void increment() {
        count++;
    }

    public synchronized int getCount() {
        return count;
    }
}

class MyRunnable implements Runnable {
    private final Counter counter;

    public MyRunnable(Counter counter) {
        this.counter = counter;
    }

    public void run() {
        for (int i = 0; i < 1000; i++) {
            counter.increment();
        }
    }
}

public class Main {
    public static void main(String[] args) {
        Counter counter = new Counter();
        Thread thread1 = new Thread(new MyRunnable(counter));
        Thread thread2 = new Thread(new MyRunnable(counter));
        thread1.start();
        thread2.start();
        try {
            thread1.join();
            thread2.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("Count: " + counter.getCount());
    }
}
```
В этом примере два потока увеличивают счетчик в общем объекте `Counter`. Главный поток дожидается их завершения, используя `join()`, прежде чем выводить итоговое значение счетчика.

##### Пример 2: Подсчет суммы в потоках
```java
class MyThread extends Thread {
    private int result;

    public void run() {
        result = 0;
        for (int i = 1; i <= 10; i++) {
            result += i;
        }
    }

    public int getResult() {
        return result;
    }
}

public class Main {
    public static void main(String[] args) throws InterruptedException {
        MyThread thread1 = new MyThread();
        MyThread thread2 = new MyThread();
        thread1.start();
        thread2.start();
        thread1.join();
        thread2.join();
        int result = thread1.getResult() + thread2.getResult();
        System.out.println("Result: " + result);
    }
}
```
Здесь два потока вычисляют сумму чисел, а главный поток ожидает их завершения, чтобы суммировать их результаты.


### Потоки и Демоны в Java

- В Java существуют пользовательские потоки (создаваемые программистом) и демоны.
- Основной поток запускается автоматически и отвечает за выполнение метода `main()`.
- Пользовательские потоки можно создавать из основного потока, и они выполняются параллельно ему.
- Основной поток обычно завершается последним, выполняя различные операции завершения, такие как закрытие потоков ввода-вывода и соединений с базами данных.

#### Потоки-демоны
- Потоки-демоны работают в фоновом режиме, выполняя вспомогательные операции (например, сборка мусора).
- Демоны автоматически завершаются, когда все пользовательские потоки завершили свое выполнение.
- Потоки-демоны обычно имеют низкий приоритет и используются для фоновых операций, таких как ввод-вывод или сетевое взаимодействие.

#### Создание и использование потоков-демонов

##### Получение имени текущего потока
```java
public class App {
    public static void main(String[] args) {
        var threadName = Thread.currentThread().getName();
        System.out.println("Thread that is executing: " + threadName);
    }
}
```
- Этот код иллюстрирует использование метода `Thread.getName()`, который возвращает имя текущего выполняющегося потока.

##### Пример с потоком-демоном
```java
public class App {
    public static void main(String[] args) {
        var worker = new Thread(() -> {
            try {
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            var threadName = Thread.currentThread().getName();
            System.out.println("Thread is finishing its execution with name: " + threadName);
        }, "Worker");

        var daemon = new Thread(() -> {
            while (true) {
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                var threadName = Thread.currentThread().getName();
                System.out.println("Thread is executing with name: " + threadName);
            }
        }, "Daemon");

        daemon.setDaemon(true);
        worker.start();
        daemon.start();

        var threadName = Thread.currentThread().getName();
        System.out.println("Thread is executing with name: " + threadName);
    }
}
```
- В этом примере `worker` выполняет задачу и завершается, в то время как `daemon` продолжает выполняться в бесконечном цикле.
- Установка потока как демона (`daemon.setDaemon(true)`) означает, что он будет автоматически завершен, когда все пользовательские потоки завершат свою работу.
- `setDaemon(true)` должен вызываться до запуска потока; иначе будет выброшено `IllegalThreadStateException`.

#### Общие принципы работы с потоками в Java
- Важно понимать разницу между пользовательскими потоками и демонами, особенно когда это влияет на процесс завершения приложения.
- Потоки-демоны полезны для выполнения фоновых задач, но не следует использовать их для критически важных операций, поскольку они могут быть неожиданно завершены.
- Управление жизненным циклом потоков важно для корректной работы многопоточных приложений.


## Синхронизация потоков в Java

### Проблемы многопоточности
- Последовательность выполнения действий в разных потоках может привести к неожиданным результатам.
- Параллельный доступ к общим ресурсам без должной синхронизации может вызвать гонки данных (race conditions) и привести к неправильному поведению программы.
- Взаимные блокировки и неравномерное распределение ресурсов между потоками могут снижать производительность и приводить к ошибкам.

### Синхронизация потоков
- Синхронизация в Java предоставляет механизмы для упорядочивания доступа потоков к общим ресурсам.
- Ключевое слово `synchronized` используется для определения блоков кода или методов, которые должны быть защищены от одновременного доступа нескольких потоков.

#### Методы синхронизации
1. **Модификатор `synchronized` для методов:**
   ```java
   public synchronized void method() {
       // Тело метода
   }
   ```
   Когда поток вызывает синхронизированный метод, он захватывает монитор объекта (или класса, если метод статический).

2. **Синхронизированный блок внутри методов:**
   ```java
   public void method() {
       synchronized(this) {
           // Тело синхронизированного блока
       }
   }
   ```
   Синхронизированный блок позволяет уточнить объект, монитор которого будет использован для блокировки.

### Примеры синхронизации
#### Проблема синхронизации счётчика
- Рассмотрим проблему, когда несколько потоков инкрементируют одну и ту же переменную. Без синхронизации конечное значение переменной будет непредсказуемым из-за race conditions.

#### Синхронизация с использованием `synchronized`
- Добавление `synchronized` к методу `increaseCounter` гарантирует, что каждый поток будет увеличивать счетчик последовательно, обеспечивая правильный итоговый результат.

### Потокобезопасные классы в Java
- Java предлагает потокобезопасные версии стандартных коллекций (например, `Vector`, `ConcurrentHashMap`), которые обеспечивают автоматическую синхронизацию при доступе к элементам коллекции из разных потоков, тем самым упрощая разработку многопоточных приложений.

### Понятие монитора в контексте Java
- Каждый объект в Java имеет связанный с ним монитор, который помогает управлять доступом к синхронизированным блокам кода.
- Монитор объекта содержит внутренние механизмы для управления блокировкой, ожиданием и уведомлением потоков.

#### Внутреннее устройство монитора
- Мониторы в Java содержат внутренние механизмы для управления доступом потоков, включая механизмы ожидания и уведомления (`wait()`, `notify()`, `notifyAll()`).

### Пример использования мониторов и синхронизированных блоков
Рассмотрим более сложный пример, демонстрирующий использование синхронизированных блоков с разными объектами-мониторами для разных частей кода:

```java
class Example {
    private final Object lock1 = new Object();
    private final Object lock2 = new Object();

    public void method1() {
        synchronized(lock1) {
            // Код, требующий синхронизации с использованием lock1
        }
    }

    public void method2() {
        synchronized(lock2) {
            // Код, требующий синхронизации с использованием lock2
        }
    }
}
```

В этом примере `method1` и `method2` могут выполняться параллельно, так как они синхронизированы на разных объектах.

### Потокобезопасность и атомарные операции
- Некоторые операции в Java являются атомарными (например, чтение и запись примитивных типов, за исключением `long` и `double`), что означает, что они выполняются в одном шаге без возможности прерывания.
- Использование ключевого слова `volatile` гарантирует, что чтение и запись переменной происходит напрямую в память, обеспечивая таким образом видимость изменений между разными потоками.

### Избегание блокировок (Deadlocks)
- Важно проектировать многопоточные приложения таким образом, чтобы избежать взаимных блокировок, когда два или более потоков ждут ресурсы, захваченные друг другом, создавая тем самым состояние вечного ожидания.

### Рекомендации по синхронизации
- Используйте синхронизацию экономно, чтобы не снизить производительность приложения.
- При проектировании многопоточных приложений всегда учитывайте возможность возникновения состояний гонки, взаимных блокировок и других проблем многопоточности.
- Изучайте и используйте высокоуровневые абстракции и утилиты для многопоточности из пакета `java.util.concurrent`, которые могут помочь упростить разработку многопоточных приложений и сделать ее более надежной.

# Многопоточность в Java с использованием java.util.concurrent

С появлением Java 1.5 был введён пакет `java.util.concurrent`, который представляет собой мощный инструментарий для разработки многопоточных приложений. Этот пакет содержит набор классов для реализации многопоточности, включая синхронизаторы и параллельные коллекции, обеспечивающие более высокий уровень абстракции по сравнению с традиционными методами синхронизации.


